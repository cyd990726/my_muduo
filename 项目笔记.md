## 从实现muduo库项目中学习到的C++技巧

## 1.定义基类，实现不可拷贝等基础特性的特性
代码文件位于`noncopyable.hpp`

## 适当的使用前置声明
可以查看示例`Channel.h`, 前向声明有以下好处
1. 避免循环引用
2. 减少编译时候没必要的头文件的包含，加快编译速度
3. 在头文件中使用前置声明而不是包含完整定义，减少暴露内部实现

<font color = "red">使用注意！</font>
前置声明在某些情况下不能使用
例如
```cpp
class EventLoop; 

class Channel : noncopyable {
public:
    //声明回调函数类
    using EventCallBack = std::function<void()>;
    using ReadEventCallback = std::function<void(Timestamp)>;

    Channel(EventLoop *loop, int fd);
    ~Channel();
    
    void handleEvent(Timestamp receiveTime);  
};
```
为什么在这里，EventLoop可以使用前置声明，而Timestamp不可以呢，因为
* EventLoop在这里是以指针形式EventLoop *使用的，所有指针大小都是8个字节，我们不需要知道EventLoop完整的定义
* Timestamp在这里是直接传作为函数的参数，编译的时候需要知道传值参数需要知道类型的大小和拷贝方式；
* std::function<void(Timestamp)> 也需要完整类型来生成代码。

## 多路事件分发器中EventLoop、Poller、Channel三者的关系

一个线程里面能有一个EventLoop，一个EventLoop里面只有一个Poller、可以有多个Channel。
Poller是多路事件分发器的核心IO复用模块

每个channel就是一路，所以叫多路事件分发器。

<font color = "red">注意：</font> 
EventLoop是包含p
oller和ChannelList的，但是poller和ChannelList并没有相互包含关系，因此channel要更新poller必须通过EventLoop去更新poller


## 优秀的设计技巧！
在抽象基类Poller中，有这么一个方法`static Poller * newDefaultPoller(EventLoop *loop);`，用于返回一个默认的实现。

我们实现newDefaultPoller这个方法的时候，不会在Poller.cpp中实现。因为：
* 要是在Poller.cpp中实现的话，那么必然Poller派生类必然要#include如Epoller的头文件，基类中包含派生类，这是很不合理的设计！

## 继承抽象基类的派生类怎么定义头文件
抽象基类中有纯虚函数，那么我们定义派生类的时候，头文件中关于重写的纯虚函数怎么定义呢？如下所示
```cpp
class EpollPoller : public Poller{
public:
    EpollPoller(EventLoop *);

    //重写抽象基类方法。
    Timestamp poll(int timeoutMs, ChannelList *activeChannels) override;
    void updateChannel(Channel *channel) override;
    void removeChannel(Channel *channel) override;

private:

};
```

## 构造初始化
本质上是在类构造的时候为成员变量指定构造函数。比如类A内有一个`vector<int> arr`的成员，在类A的构造函数中，我们如果这样定义构造函数的话，在创建实例的时候，执行的是`vector<int> arr(10)`这个构造方法，在类A的实例创建的时候arr的长度就是10。
```cpp
A():arr(10){}
```
如果这样定义的话，我们创建示例的时候就是默认执行`vector<int> arr`这个构造方法，arr长度为0，虽然在构造方法中可以继续变更arr的长度，但是这是在构造后做的事，会发生多余的资源移动或者拷贝。
```cpp
A(){}
```